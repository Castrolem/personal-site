I"¡?<p>A not so long time ago in a repo far far into the cloud, we started by creating a complex application with unstructured CSS. As you might imagine, it got really cumbersome for everyone on the team to work with.</p>

<p>Engineers were writing more CSS than HTML - designers had no guide posts when creating new layouts and components.</p>

<p>Over the last couple years, we‚Äôve introduced a living styleguide built on newer tools like SASS with well structured code that encourages engineers and designers to collaborate on beautiful and consistent user experiences.</p>

<h2 id="freedom-vs-cohesion">Freedom vs Cohesion</h2>
<p>Freedom breeds design decisions that are based on particular instances of content and context. In a large application design standardization falls by the wayside as the number of uniquely art directed pages increases or as additional designers begin to impose their stylistic discretion. The result is parts of the application that look good on their own, but lack any sense of cohesion as a whole.</p>

<blockquote>
  <p>Designers believe in freedom and beauty, engineers believe in consistency. The result of combining both perspectives is User Experience.</p>
</blockquote>

<h2 id="basic-design-principles">Basic Design Principles</h2>

<p>To start talking about why we decided to change our approach to the structure of our project, we‚Äôll have to talk about first of how CSS it‚Äôs considered usually.</p>

<p>CSS is a language that can be beautiful to write in, but it‚Äôs really complex to do because it does not support the Object Oriented Design that we developers are used to. And that‚Äôs where SASS comes to the rescue. It‚Äôs 2016, if you are not using some kind of pre-processor for your medium to big size project, then there‚Äôs time you‚Äôre probably giving into your stylesheets that can be used in other tasks.</p>

<p>Have you ever grabbed a design book? Basic design principles teaches that everything is inside a GRID, which by itself doesn‚Äôt give much freedom but people love GRIDs, and it‚Äôs kinda funny when you think that CSS a language engineered for designers as is it right now, doesn‚Äôt have GRIDs (read more about the working draft of CSS grids <a href="https://www.w3.org/TR/css-grid-1/">here</a>).</p>

<p>Of course there are ways to create your own GRID system, the best way is to do it using floated elements for columns and clearing the <code class="language-plaintext highlighter-rouge">floats</code> in every row. The 2015+ way it‚Äôs using <code class="language-plaintext highlighter-rouge">flexbox</code> which solves one of the most difficult tasks in the history of CSS: <strong>centering stuff</strong>, which is great but it‚Äôs not supported by most of the browsers and sometimes you need to have all of this features prefixed.</p>

<p>Just like pre-processors are great, there are tools like <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a>, which is a post-processor that will read your compiled stylesheet and add all of the prefixes necessary to make your CSS work in the latest 2 versions of each browser (You can change this configuration)</p>

<p>All this technologies are outside the W3C, but will make your SASS code work follow what this standards say, if you write the code the way it should, which lead us to the big question in the design process: <em>How to write good CSS?</em></p>

<h2 id="structuring-a-consistent-experience">Structuring a consistent experience</h2>

<p>Since CSS by itself is not that great and we have already talked about SASS letting us make OOD code, we can say that the next step for making a great design is to have a consistent experience.</p>

<p>With the supplied designs of course and with the mindset to write DRY code. After long sessions of investigation we decided that going with a structure similar to what Brad Frost - <a href="http://bradfrost.com/blog/post/atomic-web-design/">Atomic Design</a> says about the web.</p>

<p>So how can you scope a project based on components rather than pages with the designs supplied by your design team?</p>

<p>We though the best place was to start creating an interface inventory, which is a comprehensive collection of the bits and pieces that make up your interface.</p>

<p>Designs tend to be pixel perfect, so I think this is the best process you can do with your designer to start creating components that breath and are consistent.</p>

<p>Tackling a project this size required us to start small, beginning with typography settings, headings and links with real code, will let you optimize and test in every browser how the type font will look in the real life. This is an important step, the typography of your web application will dictate the size of your components.</p>

<p>After we created all this components, that of course will replace the agent supplied styles of every browser, we had to start deciding on the actual folder structure of our project. Like I stated before, we we‚Äôre heavily inspired by the concepts of Atomic Design, so we created the following folders.</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html">‚îú‚îÄ‚îÄ components
‚îú‚îÄ‚îÄ helpers
‚îú‚îÄ‚îÄ layouts
‚îú‚îÄ‚îÄ objects
‚îî‚îÄ‚îÄ settings</code></pre></figure>

<p>Each one contains a main file that include all the partial views in it and then each <code class="language-plaintext highlighter-rouge">_main_partial.scss</code> file it‚Äôs included by a main.scss which will be compiled later by our asset pipeline (Another story).</p>

<h3 id="settings">Settings</h3>
<p>With all the typography work done, we created our settings folder, the chosen one to hold all our variables and constants of our site.</p>

<p>Our variables are divided by</p>
<ul>
  <li>Typography: The baseline of our styles is set to a <code class="language-plaintext highlighter-rouge">font-size</code> in the document of <code class="language-plaintext highlighter-rouge">16px</code>, with a <code class="language-plaintext highlighter-rouge">$primary‚Äîfont-family: ‚ÄúHelvetica Neue‚Äù</code> and a <code class="language-plaintext highlighter-rouge">$secondary‚Äîfont-family: ‚ÄúMontserrat‚Äù</code> (both with all the fallbacks necessary to avoid <a href="http://www.paulirish.com/2009/fighting-the-font-face-fout/">FOUT</a>).</li>
  <li>Colors: The file that every designer will love to see first, contains all the HEX codes with correspondent names. We suggest to add a unique name to your HEX codes and then create variables that will say the type of color that it is. For example: <code class="language-plaintext highlighter-rouge">$blue-da-france: #0CAAF4;</code> it‚Äôs our main tone of blue and the base color for most of the things in the Agents application, so we have a variable that‚Äôs easier to read and correspond the role of the color <code class="language-plaintext highlighter-rouge">$base: $blue-da-france;</code>. Say you want to move from blue to red, then you only need to change this, <em>voil√†</em>.</li>
  <li>Sizes: Holds all the standard measures for margins and paddings that we can use in our application, between standard sizes to use when creating new components to the setup of some global components like our <code class="language-plaintext highlighter-rouge">box</code> style.</li>
  <li>Index: This file it‚Äôs one of the most interesting ones of our settings, it holds a SASS array of strings, each one it‚Äôs a name for a component or object that we know will have a <code class="language-plaintext highlighter-rouge">position</code> that‚Äôs not static in our stylesheet, depending on the position of the string in the array, it‚Äôs the <code class="language-plaintext highlighter-rouge">z-index</code> that we‚Äôll get compiled into the element, by doing this we avoided the terrifying situation of not knowing a bigger number for an element that needs to be in front of our fixed navigation component.</li>
  <li>Box model: have you ever worked without making all your elements have <code class="language-plaintext highlighter-rouge">box-sizing: border-box;</code>. We have, in this file we set a couple helpers to define different box-sizing ways for our elements.</li>
</ul>

<h3 id="objects">Objects</h3>
<p>Each of the small snippets of code that are re-usable and independent of where they will be put. For example <code class="language-plaintext highlighter-rouge">buttons</code>, <code class="language-plaintext highlighter-rouge">inputs</code>, <code class="language-plaintext highlighter-rouge">links</code>, <code class="language-plaintext highlighter-rouge">iconography</code>, etc.</p>

<p>It‚Äôs the second section to tackle when making a style-guide, and one of the most important steps, if you did your job at the interface inventory, then this items should be inmutable to achieve consistency.</p>

<p>For example, this is how part of our SASS looks like for our different buttons.</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html">.button {
  background-color: $base;
  border: 1px solid $base;
	color: currentColor;

  $button:  (‚Äúorange‚Äù, $orange),
            (‚Äúgreen‚Äù, $green),
            (‚Äúred‚Äù, $red),
            (‚Äúpink‚Äù, $pink),
            (‚Äúerror‚Äù, $error),
            (‚Äúvalid‚Äù, $valid);

  <span class="err">&amp;</span>:not([disabled]) {
    color: white;

    @each $name, $color in $button {
      <span class="err">&amp;</span>.#{$name} {
        background-color: $color;
        border-color: $color;

        <span class="err">&amp;</span>:focus,
        <span class="err">&amp;</span>:hover {
          $hover‚Äîcolor: darken($color, 10%);
          border-color: $hover‚Äîcolor;
          background-color: $hover‚Äîcolor;
        }
      }
    }
  }

  <span class="err">&amp;</span>[disabled] {
    color: rgba($black, .5);
    background-color: rgba($black, .1);
    border-color: rgba($black, .1);
    cursor: not-allowed;
  }
}</code></pre></figure>

<p>The big things to notice here are, we have a set of different buttons that we want to create, which are color dependent (<code class="language-plaintext highlighter-rouge">green</code>, <code class="language-plaintext highlighter-rouge">orange</code>, <code class="language-plaintext highlighter-rouge">pink</code> and <code class="language-plaintext highlighter-rouge">red</code>) or situational (<code class="language-plaintext highlighter-rouge">valid</code> and <code class="language-plaintext highlighter-rouge">error</code>). To do this, there‚Äôs a SASS loop that will create consistent styles for each of the types of buttons that we need.</p>

<p>But wait, why are you negating in this buttons disabled? Well, we like a lot the HTML5 disabled syntax, and it‚Äôs really easy to use with most JavaScript frameworks nowadays. So for our CSS we didn‚Äôt like the idea of having to add a <code class="language-plaintext highlighter-rouge">.disabled</code> class that overrides the styles of the elements. If a button is disabled, none of the styles will apply to it which means that the browser will render a disabled button faster to the user.</p>

<h3 id="layouts">Layouts</h3>
<p>Remember those famous GRIDs? Well, for our styles, we have a <code class="language-plaintext highlighter-rouge">float</code> with <code class="language-plaintext highlighter-rouge">clearfix</code> one that can be set with <code class="language-plaintext highlighter-rouge">mobile</code>, <code class="language-plaintext highlighter-rouge">tablet</code> and sizes, the first two are modifiers to the sizes, which override the styles for certain resolutions between a <code class="language-plaintext highlighter-rouge">em</code> size. This simplifies things a lot because we say that every devices between <code class="language-plaintext highlighter-rouge">47.50em</code> and <code class="language-plaintext highlighter-rouge">60.00em</code> is going to be a tablet, but since we‚Äôre using <code class="language-plaintext highlighter-rouge">ems</code> here, if a user in a desktop browser zooms into the UI, it won‚Äôt break at all, it will just display the tablet UI with bigger fonts.</p>

<p>But hey, we also talked about how cool is flexbox for centering, well, we didn‚Äôt forget about it, in our grid, if any developer adds the class <code class="language-plaintext highlighter-rouge">.flex</code> to a <code class="language-plaintext highlighter-rouge">.row</code>, the columns become easy to modify with every flexbox alignment property you can imagine and this will also work with different resolutions, how cool is that?</p>

<h3 id="components">Components</h3>
<p>Are the part that can be hard to explain sometimes, we call components all the elements that can contain objects and are displayed in a certain way always, so they would have to have a layout set and more than one object to be called a component.</p>

<p>Some of the components are also inmutable, like the pagination or tabs component, both include <code class="language-plaintext highlighter-rouge">buttons</code>, <code class="language-plaintext highlighter-rouge">links</code> and a layout that is specific, we don‚Äôt want developers to change this component unless there‚Äôs a significant change in the design department. So our solution to this was to set up a sub-folder called inmutable that contains this type of element.</p>

<p>Outside of this folder, you can find the elements that can change depending on new features or layout decisions. For example, we call everything that our agents see the <em>‚Äúpro side‚Äù</em> of the application, so every <em>‚Äùpro‚Äù</em> component can be changed by feature decisions without affecting the homebuyer side of the application that has similar or equal elements.</p>

<h2 id="the-future-is-uncertain-but-controlled">The future is uncertain but controlled</h2>

<p>From the Engineering point of view‚Ä¶</p>

<ul>
  <li>We decided a way of writing code, standardized it so any new member can follow this philosophy without much trouble, using the <strong>BEM</strong> methodology and you can read more about it <a href="https://en.bem.info/method/">here</a></li>
  <li>We now write more HTML than CSS, we can set up templates for new features without having to write anything in our components, which mean we have achieved an optimal level of consistency</li>
  <li>We follow a pattern for mobile, tablet and desktop views, everything is mobile first and scales nicely to any screen size thanks to the structure that‚Äôs set.</li>
  <li>We write our selectors with coherent names for each new feature and we do not nest them into more than 1 level for objects and 3 levels for components (read more about <a href="http://thesassway.com/intermediate/avoid-nested-selectors-for-more-modular-css">nesting</a>). Which is great because</li>
</ul>

<blockquote>
  <p>After you have your Style-guide finished. If you are writing more lines of CSS than HTML, then there‚Äôs something wrong.</p>
</blockquote>

<p>And now from the product side, we made their decisions easier to make and at the same time harder, they now have to think more about how each feature impacts the overall design of the site and if they want to change anything on it that will convert more users into using our application, but the design+development cycle has been sped up since now engineering does not have to bother designers to know if a feature is polished.</p>

<ul>
  <li>Product team knows what we have and which features they want, now they write better stories for us to tackle and follow consistent patterns.</li>
  <li>Design does not have to specify anything about objects, only components when making a new feature.</li>
  <li>Standard Sketch files were written for all the objects, when there‚Äôs need to update one of these elements, engineering is notified and can make 1 change for the whole UI, just like Sketch with their Symbol tool.</li>
  <li>Design always think about the overall product and focus more on UX.</li>
  <li>Product receives more finished features that need less polish and has less bugs.</li>
</ul>

<p>That‚Äôs the complete flow to live by of both teams and here at RealScout we‚Äôre sure that our application will grow and become better for our user base with a streamlined and consistent UI thanks to it.</p>
:ET